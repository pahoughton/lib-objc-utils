#ifndef _Str_ii_
#define _Str_ii_
//
// File:        Str.ii
// Project:	StlUtils (%PP%)
// Item:   	%PI% (%PF%)
// Desc:        
//
//  	inlines for Str
//
//
// Author:      Paul Houghton - (houghton@cworld.wiltel.com)
// Created:     06/01/95 07:53
//
// Revision History: (See end of file for Revision Log)
//
//  Last Mod By:    %PO%
//  Last Mod:	    %PRT%
//  Version:	    %PIV%
//  Status: 	    %PS%
//
//  %PID%
//

#include <StlUtilsExceptions.hh>
#include <RegexScan.hh>
#include <StrStreambuf.hh>
#include <SubStr.hh>
#include <StringUtils.hh>
#include <cctype>

#if defined( STLUTILS_DEBUG )
#define inline
#endif

// constructors  * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
Str::Str( const Str & src, size_type srcStart, size_type srcLen )
  : iostream( new StrStreambuf )
{
  append( src, srcStart, srcLen );
}

inline
Str::Str( const SubStr & src, size_type srcStart, size_type srcLen )
  : iostream( new StrStreambuf )
{
  append( src, srcStart, srcLen );
}

inline
Str::Str( const char * src, size_type srcLen )
  : iostream( new StrStreambuf )
{
  append( src, srcLen );
}

inline
Str::Str( size_type count, char src )
  : iostream( new StrStreambuf )
{
  append( count, src );
}

inline
Str::Str( InputIterator first, InputIterator last )
  : iostream( new StrStreambuf )
{
  append( first, last );
}

inline
Str::Str( istream & src, bool text, bool line )
  : iostream( new StrStreambuf )
{
  if( line )
    {
      getDelim( src, '\n', true );
      return;
    }

  if( text )
    {
      getDelim( src, " \t\r\n\f", true );
    }
  else
    {
      read( src );
    }
}

    

// append  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
Str &
Str::append( const Str & src, size_type srcStart, size_type srcLen )
{
  STLUTILS_EXCPT_OUT_OF_RANGE( srcStart > src.size(), *this );
  
  return( append( src.strbase() + srcStart,
		  min( (src.size() - srcStart ), srcLen ) ) );
}

inline
Str &
Str::append( const SubStr & src, size_type srcStart, size_type srcLen )
{
  STLUTILS_EXCPT_OUT_OF_RANGE( srcStart > src.size(), *this );
  
  return( append( src.strbase() + srcStart,
		  min( (src.size() - srcStart ), srcLen ) ) );
}

inline
Str &
Str::append( size_type count, char src )
{
  for( size_type c = 0; c < count; c++ )
    rdbuf()->sputc( src );
  return( *this );
}

inline
Str &
Str::append( char src )
{
  rdbuf()->sputc( src );
  return( *this );
}

inline
Str &
Str::append( InputIterator first, InputIterator last )
{
  for( InputIterator n = first; n != last; n++ )
    append( *n );
  return( *this );
}

// assignment  * * * * * * * * * * * * * * * * * * * * * * * * * * * *


inline
Str &
Str::assign( const Str & src, size_type srcStart, size_type srcLen )
{
  seekp( 0, ios::beg );

  if( ! good() ) 
    clear();

  return( append( src, srcStart, srcLen ) );
}

inline
Str &
Str::assign( const SubStr & src, size_type srcStart, size_type srcLen )
{
  seekp( 0, ios::beg );

  if( ! good() ) 
    clear();

  return( append( src, srcStart, srcLen ) );
}

inline
Str &
Str::assign( const char * src, size_type srcLen )
{
  seekp( 0, ios::beg );

  if( ! good() ) 
    clear();

  return( append( src, srcLen ) );
}

inline
Str &
Str::assign( size_type count, char src )
{
  seekp( 0, ios::beg );

  if( ! good() ) 
    clear();

  return( append( count, src ) );
}

inline
Str &
Str::assign( char src )
{
  seekp( 0, ios::beg );

  if( ! good() ) 
    clear();

  return( append( src ) );
}

inline
Str &
Str::assign( InputIterator first, InputIterator last )
{
  seekp( 0, ios::beg );

  if( ! good() ) 
    clear();

  return( append( first, last ) );
}


// insert  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


inline
Str &
Str::insert(
  size_type    	start,
  const Str & 	src,
  size_type    	srcStart,
  size_type    	srcLen
  )
{
  return( replace( start, 0, src, srcStart, srcLen ) );
}

inline
Str &
Str::insert(
  size_type    	    start,
  const SubStr &    src,
  size_type    	    srcStart,
  size_type    	    srcLen
  )
{
  return( replace( start, 0, src, srcStart, srcLen ) );
}

inline
Str &
Str::insert(
  size_type    	    start,
  const char *      src,
  size_type    	    srcLen
  )
{
  return( replace( start, 0, src, srcLen ) );
}

inline
Str &
Str::insert( size_type start, size_type count, char src )
{
  return( replace( start, 0, count, src ) );
}

inline
Str &
Str::insert( size_type start, char src )
{
  return( replace( start, 0, src ) );
}

inline
Str &
Str::insert( iterator before, InputIterator first, InputIterator last )
{
  return( replace( before, before, first, last ) );
}

// remove  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


inline
Str &
Str::remove( size_type start, size_type len )
{
  return( replace( start, len, (const char *)0, 0 ) );
}

inline
Str &
Str::remove( iterator which )
{
  return( replace( which - begin(), 1, (const char *)0, 0 ) );
}

inline
Str &
Str::remove( iterator first, iterator last )
{
  return( replace( first - begin(), last - first, (const char *)0, 0 ) );
}


// replace * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
Str &
Str::replace(
  size_type    	start,
  size_type    	len,
  const Str &  	src,
  size_type    	srcStart,
  size_type    	srcLen
  )
{

  return( replace( start,
		   len,
		   src.strbase() + srcStart,
		   min( srcLen, src.size() - srcStart ) ) );
}

inline
Str &
Str::replace(
  size_type    	    start,
  size_type    	    len,
  const SubStr &    src,
  size_type    	    srcStart,
  size_type    	    srcLen
  )
{

  return( replace( start,
		   len, 
		   src.strbase() + srcStart,
		   min( srcLen, src.size() - srcStart ) ) );
}

inline
Str &
Str::replace(
  size_type    start,
  size_type    len,
  char 	    src
  )
{
  return( replace( start, len, &src, 1 ) );
}
  
inline
Str &
Str::replace(
  iterator  	first,
  iterator  	last,
  const Str &  	src,
  size_type    	srcStart,
  size_type    	srcLen
  )
{

  return( replace( first - begin(),
		   last - first,
		   src.strbase() + srcStart,
		   min( srcLen, src.size() - srcStart ) ) );
}

inline
Str &
Str::replace(
  iterator  	    first,
  iterator  	    last,
  const SubStr &    src,
  size_type    	    srcStart,
  size_type    	    srcLen
  )
{

  return( replace( first - begin(),
		   last - first,
		   src.strbase() + srcStart,
		   min( srcLen, src.size() - srcStart ) ) );
}


inline
Str &
Str::replace(
  iterator  	first,
  iterator  	last,
  const char *  src,
  size_type    	srcLen
  )
{

  return( replace( first - begin(),
		   last - first,
		   src,
		   srcLen ) );
}


// iterators * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


inline
Str::iterator
Str::begin( void )
{
  return( rdbuf()->pbase() );
}

inline
Str::iterator
Str::end( void )
{
  return( begin() + size() );
}

inline
Str::const_iterator
Str::begin( void ) const
{
  return( strbase() );
}

inline
Str::const_iterator
Str::end( void ) const
{
  return( begin() + size() );
}

inline
Str::reverse_iterator
Str::rbegin( void )
{
  return( reverse_iterator( end() ) );
}

inline
Str::reverse_iterator
Str::rend( void )
{
  return( reverse_iterator( begin() ) );
}

inline
Str::const_reverse_iterator
Str::rbegin( void ) const
{
  return( const_reverse_iterator( end() ) );
}

inline
Str::const_reverse_iterator
Str::rend( void ) const
{
  return( const_reverse_iterator( begin() ) );
}


// substr  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
char &
Str::at( size_type index )
{
  static char badChar = 0;
  
  STLUTILS_EXCPT_OUT_OF_RANGE( index >= size(), badChar );
    
  return( rdbuf()->pbase()[index] );
}

inline
char 
Str::at( size_type index ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( index >= size(), 0 );
    
  return( strbase()[index] );
}

inline
SubStr
Str::substr( size_type start, size_type len )
{
  
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), SubStr( *this, npos, 0) );

  SubStr sub(  *this, start, min( size() - start, len ) );
  
  return( sub );
}

inline
const SubStr
Str::substr( size_type start, size_type len ) const
{

  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), SubStr( *this, npos, 0) );
  
  const SubStr sub( *this, start, min( size() - start, len ) );
  return( sub );
}

inline
SubStr
Str::at( size_type start, size_type len )
{
  return( substr( start, len ) );
}

inline
const SubStr
Str::at( size_type start, size_type len ) const
{
  return( substr( start, len ) );
}

inline
SubStr
Str::at( const char * pat, size_type start, size_type patLen )
{
  size_type pLen = (patLen == npos) ? (pat) ? strlen( pat ) : 0 : patLen;

  SubStr sub( *this, find( pat, start, pLen ), pLen );
  return( sub );
}

inline
const SubStr
Str::at( const char * pat, size_type start, size_type patLen ) const 
{
  const SubStr sub( *this, find( pat, start, patLen ), patLen );
  return( sub );
}

inline
SubStr
Str::at( const RegexScan & pat, size_type start )
{
  size_type patBeg = find( pat, start );

  SubStr sub( *this, patBeg, (patBeg == npos) ? 0UL : pat.matchLength() );
  return( sub );
}

inline
const SubStr
Str::at( const RegexScan & pat, size_type start ) const
{
  size_type    	patBeg = find( pat, start );
  const SubStr  sub( *this,
		     patBeg,
		     (patBeg == npos) ? 0UL : pat.matchLength() );
  return( sub );
}

inline
SubStr
Str::at( const Str & pat, size_type start )
{
  return( at( pat.strbase(), start, pat.size() ) );
}

inline
const SubStr
Str::at( const Str & pat, size_type start ) const
{
  return( at( pat.strbase(), start, pat.size() ) );
}

inline
SubStr
Str::at( const SubStr & pat, size_type start )
{
  return( at( pat.strbase(), start, pat.size() ) );
}

inline
const SubStr
Str::at( const SubStr & pat, size_type start ) const
{
  return( at( pat.strbase(), start, pat.size() ) );
}

inline
SubStr
Str::before( size_type end )
{
  return( at( (size_type)0, end ) );
}

inline
const SubStr
Str::before( size_type end ) const
{
  return( at( (size_type)0, end ) );
}

inline
SubStr
Str::after( size_type start )
{
  return( at( start, size() - start ) );
}

inline
const SubStr
Str::after( size_type start ) const
{
  return( at( start, size() - start ) );
}

// searching * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
Str::size_type
Str::find( const Str & str, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * pos = StringSearch( strbase() + start, size() - start,
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::find( const SubStr & str, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * pos = StringSearch( strbase() + start, size() - start,
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::find( const RegexScan & exp, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  return( exp.search( strbase(), start, size() ) ?
	  exp.matchStart(0) : npos );
}

inline
Str::size_type
Str::find( const char * str, size_type start, size_type strLen ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * pos = StringSearch( strbase() + start, size() - start,
				   str, strLen );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::find( char c, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * pos = strchr( cstr() + start, c );
  return( (pos == 0) ? npos : pos - strbase() );  
}


inline
Str::size_type
Str::rfind( const Str & str, size_type end ) const
{
  const char * pos = StringReverseSearch( strbase(), min( end, size() ),
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::rfind( const SubStr & str, size_type end ) const
{
  const char * pos = StringReverseSearch( strbase(), min( end, size() ),
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::rfind( const char * str, size_type end, size_type strLen ) const
{
  const char * pos = StringReverseSearch( strbase(), min( end, size() ),
				   str, strLen );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::rfind( char c, size_type end ) const
{
  if( ! size() || end == 0 )
    return( npos );
  
  size_type e = min( end, size() ) - 1;
  for( ; e > 0 && c != at( e ); e-- );
  return( (c == at(e)) ? e :
	  (c == at((size_type)0)) ? 0 : npos );
}


inline
Str::size_type
Str::ffind( const Str & str, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * pos = StringCaseSearch( strbase() + start, size() - start,
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::ffind( const SubStr & str, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * pos = StringCaseSearch( strbase() + start, size() - start,
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::ffind( const char * str, size_type start, size_type strLen ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * pos = StringCaseSearch( strbase() + start, size() - start,
				   str, strLen );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::ffind( char c, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  size_type s = start;
  for( ; s < size() && tolower( c ) != tolower( at( s ) ); s++ );
  return( (tolower( c ) == tolower( at(s) )) ? s : npos );
}


inline
Str::size_type
Str::rffind( const Str & str, size_type end ) const
{
  const char * pos = StringCaseReverseSearch( strbase(), min( end, size() ),
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::rffind( const SubStr & str, size_type end ) const
{
  const char * pos = StringCaseReverseSearch( strbase(), min( end, size() ),
				   str.strbase(), str.size() );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::rffind( const char * str, size_type end, size_type strLen ) const
{
  const char * pos = StringCaseReverseSearch( strbase(), min( end, size() ),
				   str, strLen );

  return( (pos == 0) ? npos : pos - strbase() );
}

inline
Str::size_type
Str::rffind( char c, size_type end ) const
{
  size_type e = min( end, size() ) - 1;
  for( ; e > 0 && tolower( c ) != tolower( at( e ) ); e-- );
  return( (tolower( c ) == tolower( at(e) )) ? e :
	  (tolower( c ) == tolower( at((size_type)0) )) ? 0 : npos );
}

inline
Str::size_type
Str::find_first_of( const Str & str, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  return( find_first_of( str.strbase(), start, str.size() ) );
}

inline
Str::size_type
Str::find_first_of( const SubStr & str, size_type start ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  return( find_first_of( str.strbase(), start, str.size() ) );
}
  
inline
Str::size_type
Str::find_first_of(
  const char * str,
  size_type start,
  size_type strLen ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( start > size(), npos );
  
  const char * nBeg = str;
  const char * nEnd = str + ( (strLen == npos) ? strlen( str ) : strLen );

  size_type  pos = size();
  
  for( const char * n = nBeg; n < nEnd; n++ )
    {
      const char * curPos;
      curPos = (const char *)memchr( (const void *)(strbase() + start),
				       *n ,
				       pos - start );
      
      if( curPos && (size_type)(curPos - strbase()) < pos )
	{
	  pos = curPos - strbase();
	}
    }
  
  return( pos < size() ? pos : npos );
}  

inline
Str::size_type
Str::find_last_of( const Str & s, size_type end ) const
{
  return( find_last_of( s.strbase(), end, s.size() ) );
}

inline
Str::size_type
Str::find_last_of( const SubStr & s, size_type end ) const
{
  return( find_last_of( s.strbase(), end, s.size() ) );
}

inline
Str::size_type
Str::find_last_of( const char * str, size_type end, size_type strLen ) const
{
  const char * hBeg = strbase();
  const char * hEnd = strbase() + ((end == npos) ? size() : end);

  const char * nBeg = str;
  const char * nEnd = nBeg + ((strLen == npos) ? strlen( str ) : strLen);

  for( const char * h = hEnd - 1 ; h >= hBeg; h-- )
    {
      for( const char * n = nBeg; n < nEnd; n++ )
	{
	  if( *h == *n )
	    {
	      return( h - strbase() );
	    }
	}
    }

  return( npos );
}  

inline
Str::size_type
Str::find_first_not_of( const Str & str, size_type start ) const
{
  return( find_first_not_of( str.strbase(), start, str.size() ) );  
}

inline
Str::size_type
Str::find_first_not_of( const SubStr & str, size_type start ) const
{
  return( find_first_not_of( str.strbase(), start, str.size() ) );
}

inline
Str::size_type
Str::find_first_not_of(
  const char *	str,
  size_type	start,
  size_type	strLen
  ) const
{
  size_type pos = StringFirstNotOf( strbase() + start,
				    size() - start,
				    str,
				    strLen );
  return( pos == npos ? npos : pos + start );
}

inline
Str::size_type
Str::find_last_not_of( const Str & str, size_type end ) const
{
  return( find_last_not_of( str.strbase(), end, str.size() ) );
}
 
inline
Str::size_type
Str::find_last_not_of( const SubStr & str, size_type end ) const
{
  return( find_last_not_of( str.strbase(), end, str.size() ) );
}
  
inline
Str::size_type
Str::find_last_not_of( const char * str, size_type end, size_type strLen ) const
{
  const char * hBeg = strbase();
  const char * hEnd = strbase() + ((end == npos) ? size() : end);

  const char * nBeg = str;
  const char * nEnd = nBeg + ((strLen == npos) ? strlen( str ) : strLen);

  if( ! hBeg || ! nBeg)
    return( npos );
  
  for( const char * h = hEnd - 1; h >= hBeg; h-- )
    {
      const char * n = nBeg;
      for( ; n < nEnd ; n++ )
	{
	  if( *h == *n )
	    {
	      break;
	    }
	}
      if( n == nEnd )
	{
	  return( h - strbase() );
	}
    }

  return( npos );
}

  

// from  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
Str &
Str::from( int src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( ((src < 0 ) ? src * -1 : src) , base, (src < 0) );
    }
  return( *this );
}

inline
Str &
Str::from( short src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( ((src < 0 ) ? src * -1 : src) , base, (src < 0) );
    }
  return( *this );
}

inline
Str &
Str::from( long src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( ((src < 0 ) ? src * -1 : src) , base, (src < 0) );
    }
  return( *this );
}

inline
Str &
Str::from( unsigned int src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( src , base, false );
    }
  return( *this );
}

inline
Str &
Str::from( unsigned short src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( src , base, false );
    }
  return( *this );
}

inline
Str &
Str::from( unsigned long src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( src , base, false );
    }
  return( *this );
}

#if defined( STLUTILS_HAVE_LONG_LONG )
inline
Str &
Str::from( long long src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( src , base, false );
    }
  return( *this );
}

inline
Str &
Str::from( unsigned long long src, unsigned short base )
{
  if( base == 0 )
    {
      *this << src;
    }
  else
    {
      writeNum( src , base, false );
    }
  return( *this );
}
#endif

// to  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
bool
Str::to( bool & dest ) const
{
  return( size() ? StringTo( dest, strbase(),  length() ) : false );
}

inline
bool
Str::to( int & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length(), sand ) : false );
}

inline
bool
Str::to( short & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}

inline
bool
Str::to( long & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}

inline
bool
Str::to( float & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}

inline
bool
Str::to( double & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base,  length(), sand ) : false );
}

inline
bool
Str::to( unsigned int & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}

inline
bool
Str::to( unsigned short & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}

inline
bool
Str::to( unsigned long & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}

#if defined( STLUTILS_HAVE_LONG_LONG )
inline
bool
Str::to( long long & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}

inline
bool
Str::to( unsigned long long & dest, unsigned short base, bool sand ) const
{
  return( size() ? StringTo( dest, strbase(), base, length(), sand ) : false );
}
#endif

inline
bool
Str::toBool( void ) const
{
  bool dest = false;
  StringTo( dest, strbase(), length());
  return( dest );
}

inline
int
Str::toInt( unsigned short base, bool sand ) const
{
  int dest = 0;
  to( dest, base, sand );
  return( dest );
}

inline
long
Str::toLong( unsigned short base, bool sand ) const
{
  long dest = 0;
  to( dest, base, sand );
  return( dest );
}

inline
double
Str::toDouble( unsigned short base, bool sand ) const
{
  double dest = 0;
  to( dest, base, sand );
  return( dest );
}

inline
unsigned int
Str::toUInt( unsigned short base, bool sand ) const
{
  unsigned int dest = 0;
  to( dest, base, sand );
  return( dest );
}

inline
unsigned long
Str::toULong( unsigned short base, bool sand ) const
{
  unsigned long dest = 0;
  to( dest, base, sand );
  return( dest );
}

#if defined( STLUTILS_HAVE_LONG_LONG )
inline
long long
Str::toLongLong( unsigned short base, bool sand ) const
{
  long long dest = 0;
  to( dest, base, sand );
  return( dest );
}

inline
unsigned long long
Str::toULongLong( unsigned short base, bool sand ) const
{
  unsigned long long dest = 0;
  to( dest, base, sand );
  return( dest );
}
#endif

// modifiers * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
void
Str::upcase( void )
{
  StringUpper( rdbuf()->pbase(), length() );
}

inline
void
Str::downcase( void )
{
  StringLower( rdbuf()->pbase(), length() );
}

inline
void
Str::capitalize( void )
{
  StringCapitalize( rdbuf()->pbase(), length() );
}

Str::size_type
Str::stripLeading( const char * stripChars )
{
  cstr();
  char * destStart = rdbuf()->pbase();

  size_type    srcPos = find_first_not_of( stripChars );

  if( srcPos == npos ) // no non-strip chars
    {
      size_type count = size();
      reset();
      return( count );
    }
    
  if( srcPos )
    {
      memmove( destStart,
	       destStart + srcPos,
	       length() - srcPos );
      seekp( length() - srcPos );
      return( srcPos );
    }
  else
    {
      return( 0 );
    }
}

Str::size_type
Str::stripTrailing( const char * stripChars )
{
  size_type last = find_last_not_of( stripChars );

  if( last != npos )
    {
      size_type count = length() - ( last + 1 );
  
      if( count )
	{
	  seekp( last + 1 );
	}
      return( count );
    }
  else
    {
      if( find_first_of( stripChars ) == 0 )
	{
	  size_type origSize = size();
	  reset();
	  return( origSize );
	}
      else
	{
	  return( 0 );
	}
    }
}

Str::size_type
Str::stripEnds( const char * stripChars )
{
  size_type count = stripLeading( stripChars );
  count += stripTrailing( stripChars );
  return( count );
}


// scan  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
Str::size_type
Str::scan( const Str & delimChars, bool multiDelim, size_type start )
{
  return( scan( delimChars.strbase(), multiDelim, start,
		delimChars.size() ) );
}

inline
Str::size_type
Str::scan( const SubStr & delimChars, bool multiDelim, size_type start )
{
  return( scan( delimChars.strbase(), multiDelim, start,
		delimChars.size() ) );
}

inline
Str::size_type
Str::scanString( const Str & delimStr, size_type start )
{
  return( scanString( delimStr.strbase(), start,
		      delimStr.size() ) );
}

inline
Str::size_type
Str::scanString( const SubStr & delimStr, size_type start )
{
  return( scanString( delimStr.strbase(), start,
		      delimStr.size() ) );
}

	   
inline
Str::size_type
Str::scanMatchCount( void ) const
{
  return( matches.size() );
}

inline
SubStr
Str::scanMatch( size_type scanNum )
{
  STLUTILS_EXCPT_OUT_OF_RANGE( scanNum >= scanMatchCount(), SubStr(*this, 0,0) );

  SubStr sub( *this, scanMatchStart( scanNum ), scanMatchLength( scanNum ) );
  return( sub );
}

inline
Str::size_type
Str::scanMatch( Str & dest, size_type scanNum ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( scanNum >= scanMatchCount(), 0 );

  dest.assign( *this, scanMatchStart( scanNum ), scanMatchLength( scanNum ) );

  return( dest.size() );
}

inline
Str::size_type
Str::scanMatchStart( size_type scanNum ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( scanNum >= scanMatchCount(), npos );

  return( matches[scanNum].pos );
}
  
inline
Str::size_type
Str::scanMatchLength( size_type scanNum ) const
{
  STLUTILS_EXCPT_OUT_OF_RANGE( scanNum >= scanMatchCount(), npos );

  return( matches[scanNum].len );
}


// io helpers  * * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
istream &
Str::getline( istream & src )
{
  return( getDelim( src, '\n', true ) );
}

// misc support  * * * * * * * * * * * * * * * * * * * * * * * * * * *

inline
void
Str::reset( void )
{
  seekp(0);
  seekg(0);
  clear();
}

inline
Str::size_type
Str::size( void ) const
{
  return( rdbuf()->plen() );
}

inline
Str::size_type
Str::length( void ) const
{
  return( size() );
}

inline
bool
Str::empty( void ) const
{
  return( size() == 0 );
}

inline
Str::size_type
Str::max_size( void ) const
{
  return( npos - 1 );
}

inline
const char *
Str::cstr( void ) const
{
  return( rdbuf()->cstr() );
}

inline
const char *
Str::c_str( void ) const
{
  return( rdbuf()->cstr() );
}

inline
Str::size_type
Str::copy( char * dest, size_type destLen, size_type start ) const
{
  size_type len = (destLen == npos ? size() - start :
		   min( destLen, size() - start ) );
  
  strncpy( dest, strbase() + start, len );
  if( destLen == npos || len < destLen )
    dest[ len ] = 0;
  return( len );
}

inline
StrStreambuf *
Str::rdbuf( void ) const
{
#if defined( STLUTILS_HAS_CONST_IOSRDBUF )
  return( (StrStreambuf *)ios::rdbuf() );
#else
  return( (StrStreambuf *)(bp) );
#endif
}

inline
StrStreambuf *
Str::rdbuf( void )
{
  return( (StrStreambuf *)ios::rdbuf() );
}


inline
istream &
Str::getline( char * dest, int size, char delim )
{
  return( istream::getline( dest, size, delim ) );
}

#if defined( STLUTILS_STR_UNSIGNED )
inline
istream &
Str::getline( unsigned char * dest, int size, char delim )
{
  return( istream::getline( dest, size, delim ) );
}
#endif

inline
istream &
Str::get( char & dest )
{
  return( istream::get( dest ) );
}

inline
istream &
Str::get( char * dest, int size, char delim )
{
  return( istream::get( dest, size, delim ) );
}

#if defined( STLUTILS_STR_UNSIGNED )
inline
istream &
Str::get( unsigned char * dest, int size, char delim )
{
  return( istream::get( dest, size, delim ) );
}

inline
istream &
Str::get( unsigned char & dest )
{
  return( istream::get( dest ) );
}
#endif

inline
int
Str::get( void )
{
  return( istream::get() );
}

inline
istream &
Str::get( streambuf & dest, char delim )
{
  return( istream::get( dest, delim ) );
}

  


inline
Str::operator const char * ( void ) const
{
  return( cstr() );
}

inline
char &
Str::operator [] ( size_type index )
{
  return( at(index) );
}

inline
char 
Str::operator [] ( size_type index ) const
{
  return( at(index) );
}

inline
SubStr
Str::operator () ( size_type start, size_type len )
{
  return( at( start, len ) );
}

inline
const SubStr
Str::operator () ( size_type start, size_type len ) const
{
  return( at( start, len ) );
}

inline
Str &
Str::operator =  ( const Str & src )
{
  return( assign( src ) );
}

inline
Str &
Str::operator =  ( const SubStr & src )
{
  return( assign( src ) );
}

inline
Str &
Str::operator =  ( const char * src )
{
  return( assign( src ) );
}

inline
Str &
Str::operator =  ( char src )
{
  return( assign( src ) );
}

inline
Str &
Str::operator += ( const Str & src )
{
  return( append( src ) );
}

inline
Str &
Str::operator += ( const SubStr & src )
{
  return( append( src ) );
}

inline
Str &
Str::operator += ( const char * src )
{
  return( append( src ) );
}

inline
Str &
Str::operator += ( char src )
{
  return( append( src ) );
}

inline
bool
Str::operator == ( const Str & two ) const
{
  return( compare( two ) == 0 );
}

inline
bool
Str::operator <  ( const Str & two ) const
{
  return( compare( two ) < 0 );
}

#if defined( STLUTILS_RELOPS_BROKEN )
inline
bool
Str::operator != ( const Str & rhs ) const
{
  return( ! (*this == rhs) );
}

inline
bool
Str::operator > ( const Str & rhs ) const
{
  return( rhs < *this );
}

inline
bool
Str::operator <= ( const Str & rhs ) const
{
  return( ! (rhs < *this) );
}

inline
bool
Str::operator >= ( const Str & rhs ) const
{
  return( ! (*this < rhs) );
}
#endif 

inline
bool
Str::operator == ( const SubStr & two ) const
{
  return( compare( two ) == 0 );
}

inline
bool
Str::operator <  ( const SubStr & two ) const
{
  return( compare( two ) < 0 );
}

inline
bool
Str::operator != ( const SubStr & two ) const
{
  return( !( *this == two ) );
}

inline
bool
Str::operator >  ( const SubStr & two ) const
{
  return( compare( two ) > 0 );
}

inline
bool
Str::operator <= ( const SubStr & two ) const
{
  return( compare( two ) <= 0 );
}

inline
bool
Str::operator >= ( const SubStr & two ) const
{
  return( compare( two ) >= 0 );
}

inline
bool
Str::operator == ( const char * two ) const
{
  return( compare( two ) == 0 );
}


inline
bool
Str::operator <  ( const char * two ) const
{
  return( compare( two ) < 0 );
}

inline
bool
Str::operator != ( const char * two ) const
{
  return( !( *this == two ) );
}

inline
bool
Str::operator >  ( const char * two ) const
{
  return( compare( two ) > 0 );
}

inline
bool
Str::operator <=  ( const char * two ) const
{
  return( compare( two ) <= 0 );
}

inline
bool
Str::operator >= ( const char * two ) const
{
  return( compare( two ) >= 0 );
}

inline
ostream &
operator << ( ostream & dest, const Str & str )
{
  return( str.toStream( dest ) );
}

inline
istream &
operator >> ( istream & src, Str & dest )
{
  return( dest.fromStream( src ) );
}

  

// PRIVATE  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


inline
const char *
Str::strbase( void ) const
{
  return( rdbuf()->strbase() );
}


// NON MEMBERS  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

#if !defined( inline )
#define STR_COMP_LEN	= Str::npos
#else
#define STR_COMP_LEN
#endif

inline
int
compare( const Str & one, const Str & two, Str::size_type len STR_COMP_LEN )
{
  return( one.compare( two, 0, len ) );
}

inline
int
compare( const Str & one, const SubStr & two, Str::size_type len STR_COMP_LEN )
{
  return( one.compare( two, 0, len ) );
}

inline
int
compare( const Str & one, const char * two, Str::size_type len STR_COMP_LEN )
{
  return( one.compare( two, 0, len ) );
}

inline
int
fcompare( const Str & one, const Str & two, Str::size_type len STR_COMP_LEN )
{
  return( one.fcompare( two, 0, len ) );
}

inline
int
fcompare( const Str & one, const SubStr & two, Str::size_type len STR_COMP_LEN )
{
  return( one.fcompare( two, 0, len ) );
}

inline
int
fcompare( const Str & one, const char * two, Str::size_type len STR_COMP_LEN )
{
  return( one.fcompare( two, 0, len ) );
}



inline
Str
operator + ( const Str & lhs, const Str & rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
Str
operator + ( const Str & lhs, const SubStr & rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
Str
operator + ( const Str & lhs, const char * rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
Str
operator + ( const char * lhs, const Str & rhs )
{
  Str s( lhs );
  s += rhs;
  return( s );
}

inline
bool
operator == ( const char * lhs, const Str & rhs )
{
  return( compare( lhs, rhs ) == 0 );
}

inline
bool
operator <  ( const char * lhs, const Str & rhs )
{
  return( compare( lhs, rhs ) < 0 );
}

inline
bool
operator != ( const char * lhs, const Str & rhs )
{
  return( compare( lhs, rhs ) != 0 );
}

inline
bool
operator >  ( const char * lhs, const Str & rhs )
{
  return( compare( lhs, rhs ) > 0 );
}

inline
bool
operator <= ( const char * lhs, const Str & rhs )
{
  return( compare( lhs, rhs ) <= 0 );
}

inline
bool
operator >= ( const char * lhs, const Str & rhs )
{
  return( compare( lhs, rhs ) >= 0 );
}


#if !defined( inline )
#define STR_LINEDELIM = '\n'
#else
#define STR_LINEDELIM
#endif

inline
istream &
getline( istream & src, Str & dest, char delim STR_LINEDELIM )
{
  return( dest.getDelim( src, delim ) );
}

inline
bool
StringToBool( const Str & str )
{
  return( str.toBool() );
}

#if defined( inline )
#define STR_DEF_BASE
#else
#define STR_DEF_BASE = 0
#endif


inline
int
StringToInt( const Str & str, unsigned short base STR_DEF_BASE )
{
  return( str.toInt( base ) );
}

inline
long
StringToLong( const Str & str, unsigned short base STR_DEF_BASE )
{
  return( str.toLong( base ) );
}

inline
double
StringToDouble( const Str & str, unsigned short base STR_DEF_BASE )
{
  return( str.toDouble( base ) );
}

inline
unsigned int
StringToUInt( const Str & str, unsigned short base STR_DEF_BASE )
{
  return( str.toUInt( base ) );
}

inline
unsigned long
StringToULong( const Str & str, unsigned short base STR_DEF_BASE )
{
  return( str.toULong( base ) );
}







#ifdef STD_STRING
inline
bool
Str::operator == ( const string & two ) const
{
  return( compare( two ) == 0 );
}

inline
bool
Str::operator <  ( const string & two ) const
{
  return( compare( two ) < 0 );
}

inline
Str::Str( const string & src, size_type srcStart, size_type srcLen )
  : ios( new StrStreambuf )
{
  append( src, srcStart, srcLen );
}

inline
Str &
Str::append( const string & src, size_type srcStart, size_type srcLen )
{
  STLUTILS_EXCPT_OUT_OF_RANGE( srcStart > src.length(), *this );
  
  return( append( src.c_str() + srcStart,
		  min( (src.length() - srcStart ), srcLen ) ) );
}

inline
Str &
Str::operator += ( const string & src )
{
  return( append( src ) );
}

inline
Str &
Str::assign( const string & src, size_type srcStart, size_type srcLen )
{
  seekp( 0, ios::beg );
  return( append( src, srcStart, srcLen ) );
}

inline
Str &
Str::operator =  ( const string & src )
{
  return( assign( src ) );
}

inline
Str &
Str::insert(
  size_type    	    start,
  const string &    src,
  size_type    	    srcStart,
  size_type    	    srcLen
  )
{
  return( replace( start, 0, src, srcStart, srcLen ) );
}

inline
Str &
Str::replace(
  size_type    	    start,
  size_type    	    len,
  const string &    src,
  size_type    	    srcStart,
  size_type    	    srcLen
  )
{

  return( replace( start,
		   len,
		   src.c_str() + srcStart,
		   min( srcLen, src.length() - srcStart ) ) );
}

inline
Str &
Str::replace(
  iterator  	    first,
  iterator  	    last,
  const string &    src,
  size_type    	    srcStart,
  size_type    	    srcLen
  )
{

  return( replace( first - begin(),
		   last - first,
		   src.c_str() + srcStart,
		   min( srcLen, src.length() - srcStart ) ) );
}
#endif

inline
DumpInfo< Str >
Str::dump( const char * prefix, bool showVer ) const
{
  return( DumpInfo< Str >( *this, prefix, showVer ) );
}

#if defined( inline )
#undef inline
#endif

// Revision Log:
// 
// 
// %PL%
// 
// $Log$
// Revision 5.5  2003/07/19 09:17:12  houghton
// Port to 64 bit.
//
// Revision 5.4  2001/07/26 19:28:59  houghton
// *** empty log message ***
//
// Revision 5.3  2000/06/27 11:58:39  houghton
// Added dump().
//
// Revision 5.2  2000/05/25 17:05:46  houghton
// Port: Sun CC 5.0.
//
// Revision 5.1  2000/05/25 10:33:17  houghton
// Changed Version Num to 5
//
// Revision 4.7  1999/05/09 13:01:12  houghton
// Added long long support.
//
// Revision 4.6  1998/10/13 16:24:47  houghton
// Removed #if def Linux.
// Cleanup operator <=, >= ...
//
// Revision 4.5  1998/04/02 14:18:27  houghton
// Port(Linux): functional.h implements != operator.
//
// Revision 4.4  1998/03/30 14:06:36  houghton
// Removed get( wchar ) and getline( wchar ) - not standard.
//
// Revision 4.3  1998/03/23 10:46:04  houghton
// Changed to eliminate Sun5 compiler warnings.
//
// Revision 4.2  1998/02/17 13:51:21  houghton
// Added stopAtNonDigit arg to to() methods.
//
// Revision 4.1  1997/09/17 15:12:56  houghton
// Changed to Version 4
//
// Revision 3.10  1997/09/17 11:08:47  houghton
// Changed: renamed library to StlUtils.
//
// Revision 3.9  1997/08/17 22:35:17  houghton
// Changed copy(): added support for destlen to be npos.
//
// Revision 3.8  1997/08/12 11:10:54  houghton
// Changed find_first_not_of to use new StringFirstNotOf function.
//
// Revision 3.7  1997/08/08 13:24:52  houghton
// Changed copy() to const.
//
// Revision 3.6  1997/07/18 19:16:34  houghton
// Port(Sun5): changed all locale variables named beg and end to
//     eliminate compiler warnings.
//
// Revision 3.5  1997/07/11 15:51:24  houghton
// Bug-Fix: copy() - null terminate dest if there is room.
//
// Revision 3.4  1997/03/15 18:01:43  houghton
// Changed to find_last_not_of to verify we are not working with any null
//     strings (was causing segv).
//
// Revision 3.3  1997/03/02 13:20:28  houghton
// Changed to use 'size_type'
//
// Revision 3.2  1997/01/18 17:34:43  houghton
// Bug-Fix: Linux - had to remove (actually ifdef out) functions that can
//     be created with functional.h.
//
// Revision 3.1  1996/11/14 01:24:13  houghton
// Changed to Release 3
//
// Revision 2.10  1996/11/06 18:07:01  houghton
// Changed calls to StringUtils functions to use npos for default len arg.
//
// Revision 2.9  1996/10/11 17:43:05  houghton
// Changed: Added new 'multiDelim' arg to scan methods. This arg
//   specifies if multiple consecutive instances of the delimiter are
//   ignored or create separate matches.
//      Example: 'this,is,,a,test'
//               mutliDelim == true:  4 fields
//               multiDelim == false: 5 fields (the third has a 0 length).
//
// Revision 2.8  1996/07/09 11:33:52  houghton
// Bug-Fix: Change call to StringToBool to StringTo.
//
// Revision 2.7  1996/07/04 10:29:01  houghton
// Added to( bool ).
//
// Revision 2.6  1996/05/11 11:02:55  houghton
// Bug-Fix: stripLeading was not working correctly if the string
//   only contained strip chars.
//
// Revision 2.5  1996/05/03 16:13:46  houghton
// AIX Port cleanup.
//
// Revision 2.4  1996/04/27 13:09:00  houghton
// Cleanup includes.
// Bug-Fix: if inline gets defined at the top, it needs to be undef at
//   at the bottom.
//
// Revision 2.3  1996/02/29 19:07:22  houghton
// Added some ifndefs for GNU
//
// Revision 2.2  1995/12/04 11:18:27  houghton
// Bug Fix - Can now compile with out '-DSTLUTILS_DEBUG'.
//
// Revision 2.1  1995/11/10  12:41:06  houghton
// Change to Version 2
//
// Revision 1.3  1995/11/05  15:28:47  houghton
// Revised
//
//
#endif // ! def _Str_ii_ 
